# Path: tools/load_all_tables.py
# Oracle version - inserts into existing fact_transactions table

import pandas as pd
from sqlalchemy import text
from database.db_engine import SessionLocal

BANK_CODES = ["BOI", "HDFC", "SBI", "AXIS", "ICICI", "YES", "KOTAK", "MAHB"]

CATEGORY_RULES = {
    "EMI": ["emi"],
    "CREDIT_CARD": ["credit card"],
    "FOOD": ["hotel", "food", "restaurant"],
    "SHOPPING": ["amazon", "flipkart", "mall", "shop"],
    "UTILITY": ["mobile", "recharge", "electric", "bill", "myjio"],
    "MEDICAL": ["medical", "hospital", "pharma"],
    "SERVICE": ["servic", "mandat", "renewal"],
    "INVESTMENT": ["gold", "lic", "policy"],
    "PERSONAL": ["papa", "mama"],
    "TRANSFER": ["self"],
    "REFUND": ["refund"]
}


def extract_ref_id(remarks):
    parts = remarks.split("/")
    return parts[1] if len(parts) > 1 else None


def extract_bank_code(remarks):
    for code in BANK_CODES:
        if f"/{code}/" in remarks:
            return code
    return "UNKNOWN"


def detect_category(remarks):
    r = remarks.lower()
    for cat, keys in CATEGORY_RULES.items():
        if any(k in r for k in keys):
            return cat
    return "OTHER"


def detect_method(code):
    if code == "UPI":
        return "UPI"
    if code == "CWDR":
        return "ATM"
    if "SBINT" in code.upper():
        return "INTEREST"
    return "BANK"


def detect_nature(debit, credit):
    if credit > 0 and debit == 0:
        return "INCOME"
    if debit > 0 and credit == 0:
        return "EXPENSE"
    return "TRANSFER"


def load_all_tables(csv_path, session_id):
    """
    Loads data into existing Oracle fact_transactions table.
    txn_id is auto-generated by Oracle IDENTITY column.
    """
    db = SessionLocal()

    try:
        df = pd.read_csv(csv_path)

        # DEBUG: Print actual columns in CSV
        print("=" * 80)
        print("CSV COLUMNS FOUND:", df.columns.tolist())
        print("=" * 80)

        # Handle different possible column names for date
        date_col = None
        for possible_name in ['transaction_date', 'date', 'txn_date', 'txn date', 'Date']:
            if possible_name in df.columns:
                date_col = possible_name
                break

        if not date_col:
            raise ValueError(f"No date column found. Available columns: {df.columns.tolist()}")

        # Convert date to proper datetime format for Oracle
        df["transaction_date"] = pd.to_datetime(df[date_col], errors='coerce')
        df["debit"] = df["debit"].fillna(0) if "debit" in df.columns else 0
        df["credit"] = df["credit"].fillna(0) if "credit" in df.columns else 0
        df["amount"] = df["debit"] + df["credit"]

        for _, row in df.iterrows():
            remarks = str(row["remarks"])
            txn_code = remarks.split("/")[0]

            # Convert pandas Timestamp to Python datetime for Oracle
            txn_date = row["transaction_date"]
            if pd.notna(txn_date):
                txn_date = txn_date.to_pydatetime()
            else:
                continue  # Skip rows with invalid dates

            # CRITICAL: Do NOT insert txn_id - Oracle generates it automatically

            db.execute(
                text("""
                     INSERT INTO C##FINANCE.FACT_TRANSACTIONS (session_id,
                                                               txn_date,
                                                               transaction_ref_id,
                                                               transaction_code,
                                                               transaction_method,
                                                               transaction_category,
                                                               transaction_nature,
                                                               counterparty_name,
                                                               counterparty_bank_code,
                                                               debit,
                                                               credit,
                                                               amount,
                                                               balance,
                                                               remarks)
                     VALUES (:sid,
                             TO_DATE(:dt, 'YYYY-MM-DD HH24:MI:SS'),
                             :ref,
                             :code,
                             :method,
                             :category,
                             :nature,
                             :cp_name,
                             :bank,
                             :debit,
                             :credit,
                             :amount,
                             :bal,
                             :remarks)
                     """),
                {
                    "sid": session_id,
                    "dt": txn_date.strftime('%Y-%m-%d %H:%M:%S'),
                    "ref": extract_ref_id(remarks),
                    "code": txn_code,
                    "method": detect_method(txn_code),
                    "category": detect_category(remarks),
                    "nature": detect_nature(row["debit"], row["credit"]),
                    "cp_name": remarks.split("/")[3] if len(remarks.split("/")) > 3 else "UNKNOWN",
                    "bank": extract_bank_code(remarks),
                    "debit": float(row["debit"]),
                    "credit": float(row["credit"]),
                    "amount": float(row["amount"]),
                    "bal": float(row["balance"]),
                    "remarks": remarks
                }
            )

        db.commit()

    except Exception as e:
        db.rollback()
        raise e
    finally:
        db.close()
